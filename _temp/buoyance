using UnityEngine;
using UnityEngine.Rendering.HighDefinition;


public class Floater2 : MonoBehaviour
{
    public int floaters = 4; // 부력 포인트 수
    public float buoyancyForce = 10.0f; // 부력 계수
    public float dragCoefficient = 0.1f; // 물 저항 계수
    public float angularDragCoefficient = 0.05f; // 회전 저항 계수
    public float depthBeforeSubmersion = 1.0f; // 물에 잠기기 시작하는 깊이
    public float dampingFactor = 0.2f; // 감쇠 계수로, 통통 튀는 현상 방지

    private Vector3 velocity; // 물체의 현재 속도
    private Vector3 angularVelocity; // 물체의 현재 회전 속도
    public float gravity = -9.81f; // 중력 가속도

    public WaterSurface water;
    
    // 물 표면을 검색하는 파라미터 저장
    WaterSearchParameters Search;
    // 물 표면 검색 결과 저장
    WaterSearchResult SearchResult;    
    
    public Transform parentTransform;
    
    void Update()
    {
        parentTransform = transform.parent;
        
        // 현재 위치 가져오기
        Vector3 currentPosition = parentTransform.position;

        Search.startPositionWS = parentTransform.position;
        
        water.ProjectPointOnWaterSurface(Search, out SearchResult);

        
        // 물 속에 잠긴 경우
        if (parentTransform.position.y < SearchResult.projectedPositionWS.y)
        {
            // 잠긴 정도에 따라 부력 비율 계산 (0에서 1 사이)
            float submersionRatio = Mathf.Clamp01(SearchResult.projectedPositionWS.y - parentTransform.position.y / depthBeforeSubmersion);

            // 부력 계산
            Vector3 buoyancy = new Vector3(0, buoyancyForce * submersionRatio, 0);
            velocity += buoyancy * Time.deltaTime;

            // 물 저항 계산 (속도와 반대 방향으로 저항력)
            Vector3 drag = -velocity * dragCoefficient * submersionRatio;
            velocity += drag * Time.deltaTime;
            
            // 회전 저항 계산 (회전 속도와 반대 방향으로 저항력)
            Vector3 angularDrag = -angularVelocity * angularDragCoefficient * submersionRatio;
            angularVelocity += angularDrag * Time.deltaTime;
        }
        else
        {
            // 물 밖에 있는 경우 중력 적용
            Vector3 gravityForce = new Vector3(0, gravity, 0);
            velocity += gravityForce * Time.deltaTime;
        }

        velocity *= (1 - dampingFactor * Time.deltaTime);        
        
        // 위치와 회전 업데이트
        currentPosition += velocity * Time.deltaTime;
        
        parentTransform.position = currentPosition;
        
        //transform.position = currentPosition;

        // 회전 업데이트
        Vector3 currentRotation = parentTransform.eulerAngles;
        currentRotation += angularVelocity * Time.deltaTime;
        parentTransform.eulerAngles = currentRotation;
    }
}