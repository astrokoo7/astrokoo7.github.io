---
layout: post
title: "todo"
categories: mathmetics
---

같은 코드를 여러 주체가 실행

backpress control

기능 특화별 분류

상태 의존성

io multiplex

linux aio vs epoll

https://stackoverflow.com/questions/5844955/whats-the-difference-between-event-driven-and-asynchronous-between-epoll-and-a


bundle exec jekyll serve



소켓이 끊긴게 아니라 

처리가 지연된거고 상대는 끊겼다고 생각해서 다시 보내면?

1. l,r로 제약을 뒀는데 fov는 안그러네?
2. 그럼 fov에선 l,r 제약이 없어?


1. 1/tan(fov/2) 
2. -w < Xe/tan(fov/2)  < w
3. l≤Xproj≤r
4. fov/2 == 45 == 1
5. 3번도 어떤 w가 들어와도 만족하는 식을 구했어
6. 2번도 그렇다면?
7. 1/tan(fov/2) 자체가 동차좌표계 변환식이다.
8. -1 < (Xe/tan(fov/2)) / we < 1
9. -1 < Xe / we < 1 
10. -w < n / r < w
11. -w < 1/(ops/adj) < w
12. -w < adj / ops < 1
13. (150+100)/50 = 5
14. 150/100 = 1.5


vectored I/O


https://learn.microsoft.com/en-us/archive/msdn-magazine/2014/june/directx-factor-the-canvas-and-the-camera

https://stackoverflow.com/questions/47593690/projected-decal-shader-using-forward-rendering-in-opengl-es

https://stackoverflow.com/questions/24944933/screen-position-unprojection-without-w

https://blog.popekim.com/en/

1. VectexX/VertexZ*CameraDepth
2. 1번식은 틀린 점이 없나? 맞다고 가정해 보자.
3. 여기서 모르는 값은 단 한개도 없다.
4. 논리적으로 연결이 안 될 뿐이다.
5. CameraDepth 보다 VertexZ 가 작다면 같은 값보다 큰 값이 될것이다.
6. 5번에 의해 CameraDepth와 VertexZ의 차이가 거의 없는 VectexX만 선택 된다.
7. 즉 바닥에 딱 붙은 투영 된 점들만이 선택 된다.


early z pass

https://martindevans.me/game-development/2015/02/27/Drawing-Stuff-On-Other-Stuff-With-Deferred-Screenspace-Decals/

https://mtnphil.wordpress.com/2014/05/24/decals-deferred-rendering/

https://www.patreon.com/posts/eksperimenty-s-69992522
https://samdriver.xyz/article/decal-render-intro

메인 카메라 선택 + ctrl + shift + f
https://gmls.tistory.com/116


https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@10.5/manual/writing-shaders-urp-reconstruct-world-position.html

https://blog.naver.com/mnpshino/221844164319


유니티 스키닝 쉐이더?

https://www.khronos.org/opengl/wiki/Compute_eye_space_from_window_space

왜 1/w

https://stackoverflow.com/questions/10389040/what-does-the-1-w-coordinate-stand-for-in-gl-fragcoord


https://www.gamedev.net/blogs/entry/1848486-understanding-half-pixel-and-half-texel-offsets/

그럼 어떤 메시를 그릴때 pixel로 넘어온 pos는 화면 좌표일땐데
-1, 1 로 어떻게 화면으로 변환하지?

텍셀 좌표계와 연계 된 질문

왜냐면 자꾸 clip 좌표와 텍셀 좌표를 연계시킴


-1, 1 이 view port min, max 이다.


https://learn.microsoft.com/en-us/windows/win32/direct3d9/directly-mapping-texels-to-pixels


"get world position from clip"

https://docs.unity3d.com/Manual/SL-PlatformDifferences.html

https://feepingcreature.github.io/math.html

clip -> ndc

ndc -> clip 

clip -> view


https://andrewhungblog.wordpress.com/2018/06/23/implementing-fog-of-war-in-unity/



1. 큐에 쌓고 하나씩 빼서 애니메이션 트리거링 한다.
2. 애니메이션이 실행 된다.
3. 애미메이터 상태가 변경되면서 물린 상태 코드가 호출 된다.




1. 사원수
2. 오일러 공식
3. 복소수
4. 테일러 전개

복소수 

사원수 -> 복소수 -> 오일러 공식 -> 테일러 급수 -> 초월 함수 ?


https://en.wikipedia.org/wiki/Reactor_pattern


스트레칭은 아플때까지 근력 운동은 안아프게..


unreal animation graph 처럼 unity는 ik 연산을 할 수 없나?

bone transform

역행렬

https://www.inf.ed.ac.uk/teaching/courses/cg/lectures/cg3_2013.pdf


https://forum.unity.com/threads/some-explanations-on-bindposes.86185/


https://moddb.fandom.com/wiki/OpenGL:Tutorials:Basic_Bones_System
유니티에서 본 웨이트 계산이 숨겨져있다고 말하는 글

https://forum.unity.com/threads/how-to-access-the-bone-positions-used-for-skinning-in-a-vertex-or-fragment-shader.1159070/

https://forum.unity.com/threads/get-skinned-vertices-in-real-time.15685/


모델의 월드 좌표계 본의 월드 좌표계


 https://github.com/MathNuts/SkeletalAnimation.git
https://webglfundamentals.org/webgl/lessons/webgl-skinning.html#toc

skinning 다음은 파츠


deferred render


https://stackoverflow.com/questions/1739259/how-to-use-queryperformancecounter


std::chrono::high_resolution_clock::now();


https://www.slideshare.net/leemwymw/deferred-decal

	pos = mul(_InverseMVP, pos);
	return pos.xyz / pos.w;


https://github.com/diharaw/texture-space-decals/blob/master/src/shader/decal_project_fs.glsl



메모리 변조 원리


https://learnopengl.com/Advanced-Lighting/Deferred-Shading

export MESA_GL_VERSION_OVERRIDE=3.3
git clone https://github.com/zeux/meshoptimizer.git
sudo apt install libglfw3-dev
sudo apt install libmagick++-dev
sudo apt install libglew-dev
sudo apt install mesa-utils libglu1-mesa-dev freeglut3-dev mesa-common-dev
sudo apt install libassimp-dev
sudo apt install libgl1-mesa-dev freeglut3-dev
sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys B7B3B788A8D3785C

LDFLAGS="$LDFLAGS -lglut ../Lib/libAntTweakBar.a -lX11 -L/home/astrokoo/work/ogldev/Common/3rdparty/meshoptimizer/build/debug -lmeshoptimizer"

https://skyul.tistory.com/337
http://lambda-the-ultimate.org/


https://en.wikipedia.org/wiki/Bidirectional_reflectance_distribution_function


https://sgvr.kaist.ac.kr/~sungeui/CG_S17/Slides/Lecture07.pdf
https://stackoverflow.com/questions/7959838/at-what-phase-in-rendering-does-clipping-occur


mask map

https://scahp.tistory.com/66



erly z pass 와 masked material 
https://forums.unrealengine.com/t/early-z-pass-performance-breakthrough/115013
https://blog.naver.com/PostList.naver?blogId=leesg213&from=postList&categoryNo=2
https://mgun.tistory.com/2298
https://forums.unrealengine.com/t/early-z-pass-performance-breakthrough/115013




KajiyaKayAnisotropic
https://forum.unity.com/threads/general-questions-regarding-early-z.1065779/

https://ypchoi.gitbooks.io/rendering-techniques/content/z_prepass.html



reinterpret_cast


https://github.com/OGRECave/ogre.git
https://forum.unity.com/threads/missing-changed-light_attenuation-macro.511767/
https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
https://learnwebgl.brown37.net/09_lights/lights_attenuation.html


https://claude.ai/chat/741ab9a2-b79a-450a-b5e1-67120f79fc05
https://nybot-house.tistory.com/51


https://stackoverflow.com/questions/31759347/why-do-we-implement-lighting-in-the-pixel-shader


https://learn.microsoft.com/en-us/windows/win32/dxtecharts/common-techniques-to-improve-shadow-depth-maps?redirectedfrom=MSDN


https://blog.naver.com/zxwnstn/223297902618
https://gamedev.stackexchange.com/questions/205025/how-to-execute-early-depth-test
https://www.gamedev.net/forums/topic/622047-early-z/
https://chulin28ho.tistory.com/777
https://interplayoflight.wordpress.com/2017/10/25/how-unreal-renders-a-frame/
https://ypchoi.gitbooks.io/rendering-techniques/content/z_prepass.html

z-prepass는 거리기반 소트를 쉽게 할 수 없는 밀도가 높은(역주 : 메시 내의 버택스들을 소팅할 수 없기 때문에 오버드로우 관리를 소팅으로 해결 못함) 나뭇잎 같은 지오메트리의 경우 특히 오버드로우를 줄이는데 도움을 줍니다.


early z 실행 조건이 다음과 같을때 

1. 바인딩된 FS 에서 z값을 조작하지 않을것 (굳이 언리얼을 끼언자면 PDO - pixel depth offset 가 대표적)

2. 바인딩된 FS 에서 discard 표현식이 없을것(비록 조건절 내부에 있더라도)

3. 뎁스 쓰기와 알파테스트가 활성화 되지 않을것

3번이라면 gpu가 정말로 안쓸려고 비활성화 한 경우와 early z 를 위해 쓰기를 활성화 한 경우를 어떻게 구분하지?

https://community.khronos.org/t/early-z-and-discard/74748/6

the sampled demonstrates two ways to take advantage of early z rejection:
front to back rendering and z prepass. with a z prepass the first pass populates the Z buffer with depth values from all opaque geometry.

a null pixel shader is used, and the color buffer is not updated.

for the second pass, the geometry is resubmitted with Z writes disabled but Z testing on, and full vertex and pixel shading is performed.


https://developer.arm.com/documentation/102224/0200/Early-Z
discard(), gl_FragDepth, Alpha-to-coverage



read lock, write lock

read concurrency, write concurrency




read가 많은 cache 설정 시 장점

read thread 개수가 많고 write thread 는 최소

read 를 동시에 많이 할 수 있고 write 요청 처리시 모든 read 요청 block





https://stackoverflow.com/questions/4531508/c-opengl-z-buffer-prepass


tone mapping


https://www.infoq.com/news/2014/10/cpp-lock-free-programming/

어셈블리에서 함수 리턴 값은 레지스터에 저장? 큰 값은 어떻게?

struct A
{
        char a[100000000];
};


A Foo()
{
        return A();
}

int main()
{
        A a = Foo();
        return 0;
}

https://www.youtube.com/watch?v=fbYknr-HPYE

걱정할 필요가 없다.
데이터가 살아 있는지 확인할 필요가 없다.


making sure we keep it intact making sure we copy it

we can simply steal the resources that might be attached

to that specific object and them somewhere else because

we know that it's temporary it's not going to exist for very long where if you take in something like this then

you can't i mean apart from the fact that is's cost you

can't really steal anything from this name string

because it might be used in a number of factions whereas this is clearly something that is temporary only going to be used with this particular call of print name and that's where the power really comes from so remember L values are baically variables that have some kind of storage back in them our values 


https://www.youtube.com/watch?v=80TXwV_sdCY
https://www.linkedin.com/pulse/c-return-value-optimization-dipanjan-das-roy/
https://learn.microsoft.com/en-us/cpp/cpp/temporary-objects?view=msvc-170




unfortunately x lives right here i didnot control 


https://nanze.tistory.com/entry/Cpp-Universal-reference-Reference-Collapsing-Rules

unique_ptr과 std::move


https://velog.io/@kodskm/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B2%BD%EC%9A%B0%EC%9D%98-%EC%88%98-%EA%B0%9C%EB%85%90


https://solved.ac/
https://github.com/codeisneverodd/programmers-coding-test




명시적으로 constructor를 호출해야 함
make_unique는 가능함


https://github.com/daancode/a-star

https://www.youtube.com/watch?v=atTzqxbt4DM&list=PLi-xJrVzQaxXC2Aausv_6mlOZZ2g2J6YB&index=4


https://github.com/ChangguHan/codingtestbasic/blob/master/BJ15649.py


https://www.acmicpc.net/problem/1753

```c++
#include <iostream>
#include <vector>
using namespace std;

int N, M;
vector<int> rs;
vector<bool> chk;

void recur(int num) {
    if (num == M) {
        for (int i = 0; i < M; ++i) {
            cout << rs[i] << " ";
        }
        cout << endl;
        return;
    }
    for (int i = 1; i <= N; ++i) {
        if (!chk[i]) {
            chk[i] = true;
            rs.push_back(i);
            recur(num + 1);
            chk[i] = false;
            rs.pop_back();
        }
    }
}

int main() {
    cin >> N >> M;
    chk.resize(N + 1, false);
    recur(0);
    return 0;
}


https://ansohxxn.github.io/algorithm/ahocorasick/


git index
https://johngrib.github.io/wiki/git/index/
checkout 

주사위 눈이 아래와 같을 때 
1 2 3 4 5 6
더해서 30 이 되는 모든 경우의 수


recursion

	for i = 0 ~ n

		if i == 30
			exit

		recursion i + 1



int main() {

	vector<int> dise = {1, 2, 3, 4, 5, 6};

	for (int i = 0; i < dise.size(); i++) {
		for (int j = 0; j < dise.size(); j++) {
			cout << dise[i] << "," << dise[j] << endl;
		}
	}

	// 여러번 굴리기
	for (int i = 0; i < dise.size(); i++) {
	}
	for (int j = 0; j < dise.size(); j++) {
	}
	for (int k = 0; k < dise.size(); k++) {
	}

	function<void(int)> run;
	int runCount = 0;
	int	playLimit = 10;
		
	// n 번 굴리기
	run = [&run, &playLimit](int runCount) -> void {

		if (runCount == playLimit) {
			return;
		}
		run(++runCount);
	};
	run(runCount);

	// dfs는 base 자료 구조가 2차원. MxN 좌표 

	return 0;
}        


https://github.com/da-in/tech-interview-study/tree/main

자리까지 맞는 데이터간 비교를 통해  정확한 문자를 찾는다.


using namespace std;

//vector<int> dise = { 1,2,3,4,5,6 };
//int diceCnt = 6;
//int boardCnt = 4;

//vector<int> dise = { 2, 5 };
//int diceCnt = 2;
//int boardCnt = 10;

vector<int> dise = { 1,2,3,4,5,6 };
int diceCnt = 6;
int boardCnt = 30;

int sum;
int result;
vector<int> valueToIndex;
int bigDice;
vector<int> progress;
vector<int> failed;

int g;
int p;

struct ScopeTime
{
    ScopeTime(const char* InScopeMessage)
    {
        start = std::chrono::high_resolution_clock::now();
        MessageString = InScopeMessage;
    }

    ~ScopeTime()
    {
        auto end = chrono::high_resolution_clock::now();
        chrono::duration<double> elapsed_seconds = end - start;
        cout << MessageString << " : " << elapsed_seconds.count() * 1000 << " msec" << endl;
    }

    chrono::time_point<std::chrono::high_resolution_clock> start;
    const char* MessageString;
};

void calculate(int index)
{
    for (int i = index; 0 <= i; i--) {
        auto val = dise[i];
        auto need = boardCnt - (sum + val);

        if (need < 0) {
            continue;
        } 
        else if (need == 0) {
            result++;
            continue;
        }
        else {
            index = valueToIndex[need];
            sum += val;
            calculate(index);
            sum -= val;
        }
    }
}

int main() {
   /* Enter your code here. Read input from STDIN. Print output to STDOUT */

    std::sort(dise.begin(), dise.end());

    auto s = dise.size() - 1;

    bigDice = dise[s];
    valueToIndex.resize(30, s);
    valueToIndex[bigDice] = s;

    for (int i = dise.size() - 1; 0 <= i; i--) {
        auto value = dise[i];
        valueToIndex[value] = i;
    }

    for (int i = bigDice - 1; 0 <= i; i--) {
        auto index = valueToIndex[i];
        if (index < 0) {
            valueToIndex[i] = s;
        }
        else {
            s = index;
        }
    }

    {
        diceCnt -= 1;
        ScopeTime checkTime("calculate");
        calculate(diceCnt);
    }

    cout << result;
    return 0;
}



1. 캐릭터당 draw call 개수
2. signed distance (https://scahp.tistory.com/17)
3. kd 알고 (https://www.baeldung.com/cs/k-d-trees) or r tree
4. str 알고
5. Terrain Layers
6. mono time steady time
7. covolution (확률 함수/적분/계수/확률이산분포)
8. marshal
9. pbr vs none pbr
10. string 과 stream
11. make_shared를 사용하는 이유, 순환 참조
12. bcs class 구조 (어떤 생각으로 짰는지, iocp zero copy)
13. terrain rendering (https://www.reddit.com/r/GraphicsProgramming/comments/13i55ae/whats_the_stateoftheart_terrain_rendering/)


https://bytewrangler.blogspot.com/2011/10/signed-distance-fields.html
https://linkmemo.tistory.com/category/C%2B%2B%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D
https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii


https://stackoverflow.com/questions/20895648/difference-in-make-shared-and-normal-shared-ptr-in-c



Why use a socket broadcast server?

모든 물리적 장치와 사용자 프로세스 간에는 버퍼가 존재한다.

프로세스는 물리적 장치를 사용하기 위해선 커널의 스케줄링을 따라 버퍼를 통하여 데이터를 주고받으며 사용한다.

네트웍 장치의 경우 os 커널은 소켓이란 논리적 단위로 처리한다. 

소켓은 버퍼를 가지고 있고 유저는 버퍼에 데이터를 쓰거나 읽어서 네트웍 통신을 한다.

버퍼에 읽거나 쓸 때 커널 영역의 데이터를 유저 영역으로 복사한다.

만약 엄청나게 많은 유저를 받아 처리하는 서버가 있다고 생각해 보자.

각각의 유저는 네트웍 통신을 위해 저마다 소켓을 통해 데이터를 복사하며 주고받는다.

n 명의 유저가 n 개의 소켓에 저마다 필요에 의해 커널 영역의 데이터를 유저 영역으로 복사한다면

유저가 증가할수록 비용은 O(n^2)이 될 수 있다.

n 명의 유저의 네트웍 입력 출력을 따로 받는 전용 서버가 있고 뒷단의 서버는 적은 소켓을 통해 데이터를 

받는다면 어떨까?

로직 전용 서버는 배치 효과를 통한 이득이 있고 

소켓 방송 서버가 윈도우라면 IOCP를 통한 커널 버퍼와 유저 간 zero copy의 이득을 볼 수 있을 것이다.

마치 erlang이 mmap을 통해 new 를 재정의 한 것처럼..
