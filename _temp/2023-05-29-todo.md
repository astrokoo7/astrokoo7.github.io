---
layout: post
title: "todo"
categories: mathmetics
---

c++ universal reference

reflect

compute shader

tone mapping

normal map

시간 복잡도

b tree

투영 변환

w = z / n


w = 10 / 2 = 5


py = y / w



nY / nZ = y / z

nY = y / z * nZ


nY = y * nZ / z

w = z / nZ

nY = y / w


1 0 0 0

0 1 0 0

0 0 1 0

0 0 w 0

y'/z' = y/z

y' = y * z' / z


z' 0 0 0

0 z' 0 0 

0 0 1 0



(f + n) / (f - n) 의 기하학적 의미

(6 + 4) / (6 - 4) = 10 / 2

2개씩 나눌때 가분수는 약분하면 4개 진분수는 없음

4

(7 + 4) / (7 - 4) = 11 / 3 

3개씩 나눌때 가분수는 약분하면 3개 진분수는 2/3 

2를 3등분하면 0.66

3.66

(2 + 4) / (2 - 4) = 6 / -2


-3


*
- 
-----

------
-----

1.2


*
--- 
----

-------
----

1.75


*
--- 
---

------
---

2

*
-- 
-------------------

---------------------
-------------------

1.105

*
--
---

-----
---

1.666

*
---
----------------------

-------------------------
----------------------


*
-
-------------------------------------------


--------------------------------------------
-------------------------------------------

*
-
-------------------------------------------------------------------


--------------------------------------------------------------------
-------------------------------------------------------------------


*
--------------------------------------------------------------
---------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------
-

*
-
--

---
-


*
-
--------

---------
--------


*
--
-------------------------------------------------------------------


---------------------------------------------------------------------
-------------------------------------------------------------------





차이가 전체 합 대비 작을수록 값이 커진다.


fov 가 45도 기준 각도가 작아질수록 x 값이 커지고 반대로 각도가 커질수록 x 값이 작아진다.
=> 각도가 작아질수록 x 값이 커저 원래 보이던 x 값이 안보이게 된다.
=> 좌우 확대

near와 far의 차이가 작을수록 값이 커진다. 반대로 차이가 클수록 값이 작아진다
=> 차이가 작을수록 z 값이 커져 안보이게 된다
=> 앞뒤 확대


y = (f + n) / (f - n)

두개의 인풋이 있고 아웃풋이 있다.

두개의 인풋에 대해 아웃풋이 어떻게 변화하는지 그래프로 그리고 싶다.

이건 3차원 그래프?

아님 y, f 의 2차원 그래프로 두고 n 값을 slide 하는게 좋을까?









머리속 논리 연산 작용은 활발하게 일어나는가?


fn - zn / (f - n)


fn - fn = 0

fn - nn = n(f - n) / (f - n) = n 



카메라 좌표계의 z 값은 near와 같으면 0으로 far와 같으면 1로 정규화한다.

장치 관점에선 어떤 near와 far가 설정되던 정규화 된 z 값을 받되 0 보다 작거나 1보다 크면 버린다.

입력 z가 near와 같으면 0을 출력해야 하고 far와 같으면 1을 출력해야 한다. 

near가 1이고 far가 10이라 가정해보자

입력 z = 1 일때 z 와 near 는 같기에

z = near 정의 할 수 있다.

위 식에 입력 z = 2 이면 near 도 2 가 되야하는데 near 값은 상수여서 변하면 안된다.

따라서 z = near 란 식은 쓸 수 없다.



z = 1 일때 z = near 을 만족하면서도 

z = 2 일때 z != near 여야한다.

z 를 만족하는 방정식은 무얼까?






























정규화하기 위해 f와 n


