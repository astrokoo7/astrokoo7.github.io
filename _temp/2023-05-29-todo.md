---
layout: post
title: "todo"
categories: mathmetics
---

같은 코드를 여러 주체가 실행

backpress control

기능 특화별 분류

상태 의존성

io multiplex

linux aio vs epoll

https://stackoverflow.com/questions/5844955/whats-the-difference-between-event-driven-and-asynchronous-between-epoll-and-a


bundle exec jekyll serve



소켓이 끊긴게 아니라 

처리가 지연된거고 상대는 끊겼다고 생각해서 다시 보내면?

1. l,r로 제약을 뒀는데 fov는 안그러네?
2. 그럼 fov에선 l,r 제약이 없어?


1. 1/tan(fov/2) 
2. -w < Xe/tan(fov/2)  < w
3. l≤Xproj≤r
4. fov/2 == 45 == 1
5. 3번도 어떤 w가 들어와도 만족하는 식을 구했어
6. 2번도 그렇다면?
7. 1/tan(fov/2) 자체가 동차좌표계 변환식이다.
8. -1 < (Xe/tan(fov/2)) / we < 1
9. -1 < Xe / we < 1 
10. -w < n / r < w
11. -w < 1/(ops/adj) < w
12. -w < adj / ops < 1
13. (150+100)/50 = 5
14. 150/100 = 1.5


vectored I/O


https://learn.microsoft.com/en-us/archive/msdn-magazine/2014/june/directx-factor-the-canvas-and-the-camera

https://stackoverflow.com/questions/47593690/projected-decal-shader-using-forward-rendering-in-opengl-es

https://stackoverflow.com/questions/24944933/screen-position-unprojection-without-w

https://blog.popekim.com/en/

1. VectexX/VertexZ*CameraDepth
2. 1번식은 틀린 점이 없나? 맞다고 가정해 보자.
3. 여기서 모르는 값은 단 한개도 없다.
4. 논리적으로 연결이 안 될 뿐이다.
5. CameraDepth 보다 VertexZ 가 작다면 같은 값보다 큰 값이 될것이다.
6. 5번에 의해 CameraDepth와 VertexZ의 차이가 거의 없는 VectexX만 선택 된다.
7. 즉 바닥에 딱 붙은 투영 된 점들만이 선택 된다.


early z pass

https://martindevans.me/game-development/2015/02/27/Drawing-Stuff-On-Other-Stuff-With-Deferred-Screenspace-Decals/

https://mtnphil.wordpress.com/2014/05/24/decals-deferred-rendering/

https://www.patreon.com/posts/eksperimenty-s-69992522
https://samdriver.xyz/article/decal-render-intro

메인 카메라 선택 + ctrl + shift + f
https://gmls.tistory.com/116


https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@10.5/manual/writing-shaders-urp-reconstruct-world-position.html

https://blog.naver.com/mnpshino/221844164319


유니티 스키닝 쉐이더?

https://www.khronos.org/opengl/wiki/Compute_eye_space_from_window_space

왜 1/w

https://stackoverflow.com/questions/10389040/what-does-the-1-w-coordinate-stand-for-in-gl-fragcoord


https://www.gamedev.net/blogs/entry/1848486-understanding-half-pixel-and-half-texel-offsets/

그럼 어떤 메시를 그릴때 pixel로 넘어온 pos는 화면 좌표일땐데
-1, 1 로 어떻게 화면으로 변환하지?

텍셀 좌표계와 연계 된 질문

왜냐면 자꾸 clip 좌표와 텍셀 좌표를 연계시킴


-1, 1 이 view port min, max 이다.


https://learn.microsoft.com/en-us/windows/win32/direct3d9/directly-mapping-texels-to-pixels


"get world position from clip"

https://docs.unity3d.com/Manual/SL-PlatformDifferences.html

https://feepingcreature.github.io/math.html

clip -> ndc

ndc -> clip 

clip -> view


https://andrewhungblog.wordpress.com/2018/06/23/implementing-fog-of-war-in-unity/



1. 큐에 쌓고 하나씩 빼서 애니메이션 트리거링 한다.
2. 애니메이션이 실행 된다.
3. 애미메이터 상태가 변경되면서 물린 상태 코드가 호출 된다.




1. 사원수
2. 오일러 공식
3. 복소수
4. 테일러 전개

복소수 

사원수 -> 복소수 -> 오일러 공식 -> 테일러 급수 -> 초월 함수 ?


https://en.wikipedia.org/wiki/Reactor_pattern


스트레칭은 아플때까지 근력 운동은 안아프게..


unreal animation graph 처럼 unity는 ik 연산을 할 수 없나?

bone transform

역행렬

https://www.inf.ed.ac.uk/teaching/courses/cg/lectures/cg3_2013.pdf


https://forum.unity.com/threads/some-explanations-on-bindposes.86185/


https://moddb.fandom.com/wiki/OpenGL:Tutorials:Basic_Bones_System
유니티에서 본 웨이트 계산이 숨겨져있다고 말하는 글

https://forum.unity.com/threads/how-to-access-the-bone-positions-used-for-skinning-in-a-vertex-or-fragment-shader.1159070/

https://forum.unity.com/threads/get-skinned-vertices-in-real-time.15685/


모델의 월드 좌표계 본의 월드 좌표계


 https://github.com/MathNuts/SkeletalAnimation.git
https://webglfundamentals.org/webgl/lessons/webgl-skinning.html#toc

skinning 다음은 파츠


deferred render


https://stackoverflow.com/questions/1739259/how-to-use-queryperformancecounter


std::chrono::high_resolution_clock::now();


https://www.slideshare.net/leemwymw/deferred-decal

	pos = mul(_InverseMVP, pos);
	return pos.xyz / pos.w;


https://github.com/diharaw/texture-space-decals/blob/master/src/shader/decal_project_fs.glsl



// Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)'

// Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)'

Shader "Unlit/NewUnlitShader"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
    }
    SubShader
    {
        Tags { "RenderType"="Opaque" }
        LOD 100

        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            // make fog work
            #pragma multi_compile_fog
            
            #include "UnityCG.cginc"

            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                float4 vertex : SV_POSITION;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;
            
            v2f vert (appdata v)
            {
                v2f o;
                //o.vertex = UnityObjectToClipPos(v.vertex);
                o.vertex = UnityObjectToClipPos(float4(v.vertex.xyz, 1.0));

                o.uv = TRANSFORM_TEX(v.uv, _MainTex);
                return o;
            }
            
            fixed4 frag (v2f i) : SV_Target
            {
                // sample the texture
                fixed4 col = fixed4(i.vertex.x, i.vertex.y, i.vertex.z, 1);
                return col;
            }
            ENDCG
        }
    }
}


using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class NewBehaviourScript : MonoBehaviour
{
    public Material material;
    public Vector3 upper = new Vector3(0, 5, 0);

    // Start is called before the first frame update
    void Start()
    {
        gameObject.AddComponent<Animation>();
        gameObject.AddComponent<SkinnedMeshRenderer>();
        SkinnedMeshRenderer rend = GetComponent<SkinnedMeshRenderer>();
        Animation anim = GetComponent<Animation>();

        // Build basic mesh
        Mesh mesh = new Mesh();
        mesh.vertices = new Vector3[] { new Vector3(-1, 0, 0), new Vector3(1, 0, 0), new Vector3(-1, 5, 0), new Vector3(1, 5, 0) };
        mesh.uv = new Vector2[] { new Vector2(0, 0), new Vector2(1, 0), new Vector2(0, 1), new Vector2(1, 1) };
        mesh.triangles = new int[] { 2, 3, 1, 2, 1, 0 };
        mesh.RecalculateNormals();
        rend.material = material;

        // assign bone weights to mesh
        BoneWeight[] weights = new BoneWeight[4];
        weights[0].boneIndex0 = 0;
        weights[0].weight0 = 1;
        weights[1].boneIndex0 = 0;
        weights[1].weight0 = 1;
        weights[2].boneIndex0 = 1;
        weights[2].weight0 = 1;
        weights[3].boneIndex0 = 1;
        weights[3].weight0 = 1;
        mesh.boneWeights = weights;

        // Create Bone Transforms and Bind poses
        // One bone at the bottom and one at the top

        Transform[] bones = new Transform[2];
        Matrix4x4[] bindPoses = new Matrix4x4[2];
        bones[0] = new GameObject("Lower").transform;
        bones[0].parent = transform;
        // Set the position relative to the parent
        bones[0].localRotation = Quaternion.identity;
        bones[0].localPosition = Vector3.zero;
        // The bind pose is bone's inverse transformation matrix
        // In this case the matrix we also make this matrix relative to the root
        // So that we can move the root game object around freely
        //bindPoses[0] = bones[0].worldToLocalMatrix;
        bindPoses[0] = bones[0].worldToLocalMatrix * transform.localToWorldMatrix;

        bones[1] = new GameObject("Upper").transform;
        bones[1].parent = transform;
        // Set the position relative to the parent
        bones[1].localRotation = Quaternion.identity;
        bones[1].localPosition = upper;
        // The bind pose is bone's inverse transformation matrix
        // In this case the matrix we also make this matrix relative to the root
        // So that we can move the root game object around freely
        //bindPoses[1] = bones[1].worldToLocalMatrix;
        bindPoses[1] = bones[1].worldToLocalMatrix * transform.localToWorldMatrix;

        // 배치 할때 이동한 루트 본 만큼은 다시 적용


        // bindPoses was created earlier and was updated with the required matrix.
        // The bindPoses array will now be assigned to the bindposes in the Mesh.
        //mesh.bindposes = bindPoses;

        // Assign bones and bind poses
        rend.bones = bones;
        rend.sharedMesh = mesh;

        // Assign a simple waving animation to the bottom bone
        AnimationCurve curve = new AnimationCurve();
        curve.keys = new Keyframe[] { new Keyframe(0, 0, 0, 0), new Keyframe(1, 3, 0, 0), new Keyframe(2, 0.0F, 0, 0) };

        // Create the clip with the curve
        AnimationClip clip = new AnimationClip();
        clip.legacy = true;
        clip.SetCurve("Lower", typeof(Transform), "m_LocalPosition.z", curve);

        // Add and play the clip
        clip.wrapMode = WrapMode.Loop;
        anim.AddClip(clip, "test");
        anim.Play("test");
    }

    // Update is called once per frame
    void Update()
    {
        SkinnedMeshRenderer skin = GetComponent<SkinnedMeshRenderer>();
        var mesh = skin.sharedMesh;

        Matrix4x4[] boneMatrices = new Matrix4x4[skin.bones.Length];
        for (int i = 0; i < boneMatrices.Length; i++)
            boneMatrices[i] = skin.bones[i].localToWorldMatrix * mesh.bindposes[i];

        Vector3[] vertices;

        var vertexCount = mesh.vertexCount;
        vertices = new Vector3[vertexCount];

        for (int i = 0; i < mesh.vertexCount; i++)
        {
            BoneWeight weight = mesh.boneWeights[i];

            var a = mesh.bindposes[weight.boneIndex0].MultiplyPoint3x4(mesh.vertices[i]);

            Matrix4x4 bm0 = boneMatrices[weight.boneIndex0];
            //Matrix4x4 bm1 = boneMatrices[weight.boneIndex1];
            //Matrix4x4 bm2 = boneMatrices[weight.boneIndex2];
            //Matrix4x4 bm3 = boneMatrices[weight.boneIndex3];

            Matrix4x4 vertexMatrix = new Matrix4x4();

            for (int n = 0; n < 16; n++)
            {
                vertexMatrix[n] =
                    bm0[n] * weight.weight0;
                    //bm1[n] * weight.weight1;
                    //bm2[n] * weight.weight2 +
                    //bm3[n] * weight.weight3;
            }

            vertices[i] = vertexMatrix.MultiplyPoint3x4(mesh.vertices[i]);
        }
    }
}


Shader "Decals/ScreenSpace"
{
    Properties
    {
        [NoScaleOffset]
        _MainTex ("Texture", 2D) = "white" {}
        _BlendStart("Blend Start", Range(0,1)) = 0.5
    }
    SubShader
    {
        Tags { "RenderType"="Opaque" }

        ZWrite On
        //Blend SrcAlpha OneMinusSrcAlpha

        Pass
        {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            // make fog work
            #pragma multi_compile_fog
            
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl"

            struct appdata
            {
                float4 vertex : POSITION;
            };

            struct v2f
            {
                float4 vertex : SV_POSITION;

            };

            TEXTURE2D(_MainTex);
            SAMPLER(sampler_MainTex);
            float _BlendStart;

            v2f vert (appdata v)
            {
                v2f o;
                //o.vertex = TransformObjectToHClip(v.vertex);
                o.vertex = mul(UNITY_MATRIX_MVP, float4(v.vertex.x,v.vertex.y, 0.5,1));

                return o;
            }

            float3 ComputeWorldPosition(float2 screenUv)
            {
                #if UNITY_REVERSED_Z
                float depth = SampleSceneDepth(screenUv);
                if (depth < 0.0001) discard;
                #else
                float depth = lerp(UNITY_NEAR_CLIP_VALUE, 1, SampleSceneDepth(screenUv));
                if (depth > 0.9999) discard;
                #endif

                return ComputeWorldSpacePosition(screenUv, depth, UNITY_MATRIX_I_VP);
            }

            bool IsInsideBox(float3 v)
            {
                return v.x < 0.5 && v.x > -0.5
                    && v.y < 0.5 && v.y > -0.5
                    && v.z < 0.5 && v.z > -0.5;
                // const float min = float3(-0.5,-0.5,-0.5);
                // const float max = float3(0.5,0.5,0.5);
                // float3 minStep = step(min, v);
                // float3 maxStep = step(max, v);
                // float3 s = minStep - maxStep;
                // return s.x * s.y * s.z > 0;
            }

            float4 frag (v2f i) : SV_Target
            {
                float2 screenUv = i.vertex.xy / _ScaledScreenParams.xy;

                float depth = SampleSceneDepth(screenUv);
                // if (depth < 0.0001) discard;

                float2 deproject = float2(UNITY_MATRIX_I_P[0][0], UNITY_MATRIX_I_P[1][1]);

                //float4 scenePosView = float4(i.vertex.xy * depth / (deproject.xy * i.vertex.w), -depth, 1);
                float4 scenePosView = float4(i.vertex.xy * depth / (deproject.xy), -depth, 1);
                //float4 scenePosView = float4(i.vertex.xy / (deproject.xy), -depth, 1);

                float4 position = mul(UNITY_MATRIX_I_V, scenePosView);
                position = mul(UNITY_MATRIX_I_M, position);

                //clip(0.5f - abs(position.xyz));

                //float4 col2 = float4(position.x,position.y*0.00003,0,0);
                //float4 col2 = float4(scenePosView.x*0.0001,scenePosView.y*0.0001,0,0);
                float4 col2 = float4(i.vertex.x*0.0001,i.vertex.y*0.0001,0,0);
                return col2;
            }
            ENDHLSL
        }
    }
}
