
1. 캐릭터당 draw call 개수
- 재질에 따라 드로우하니 재질별로 머리,얼굴,그외로 나누면 되지만
- 같은 머터리얼이지만 텍스처가 다른 몸과 손은 따로 그리고 있음. 
- srp batch를 사용하면 하나로 그릴 수 있나?
2. signed distance (https://scahp.tistory.com/17)
3. kd 알고 (https://www.baeldung.com/cs/k-d-trees) or r tree
4. str 알고
5. Terrain Layers
6. mono time steady time
7. covolution (확률 함수/적분/계수/확률이산분포)
8. marshal
9. pbr vs none pbr
10. string 과 stream
11. make_shared를 사용하는 이유, 순환 참조
12. bcs class 구조 (어떤 생각으로 짰는지, iocp zero copy)
13. terrain rendering (https://www.reddit.com/r/GraphicsProgramming/comments/13i55ae/whats_the_stateoftheart_terrain_rendering/)
14. array segment (https://velog.io/@yarogono/C-ArraySegment%EB%9E%80) c++에서 같은 기능을 하는 클래스는 없나요? C++에서는 포인터 사용으로 부분 접근이 가능합니다. (배열에서 특정 부분을 따로 때낼수가 없다는 거구나)
15. shadow (https://illu.tistory.com/1253)
16. shadow mask (https://catlikecoding.com/unity/tutorials/custom-srp/shadow-masks/)
17. pixel to world when (https://stackoverflow.com/questions/13419605/how-to-map-x-y-pixel-to-world-cordinates)
18. unity rendering (https://junbastick.tistory.com/6)
19. hdr (https://docs.unity3d.com/560/Documentation/Manual/HDR.html)
20. tone mapping (https://forum.unity.com/threads/texture-creation-workflow-for-tonemapping.1343789/) / 실제로 hdr 에서 tonemap 하기전까지 밝아야하는게 아닌지... 그런 셈풀이 있는지
21. gamma space (https://blog.naver.com/PostView.nhn?blogId=cdw0424&logNo=221827528747)
22. bloom filtering 
- https://junbastick.tistory.com/67?category=1008778
- https://learnopengl.com/code_viewer_gh.php?code=src/5.advanced_lighting/7.bloom/bloom.cpp (MRT)
- unity는 original을 받아서 다운 셈플링하면서 시작 (MRT는 원본과 같은 상태 필터링 후 그걸 인풋으로 시작)
23. FragmentCommonData 이거 확인
24. srgb (https://unlimited3d.wordpress.com/2020/01/08/srgb-color-space-in-opengl/)
25. simd & shader if statement (https://jahej.com/alt/2011_04_06_if-simd-o_o-or-how-to-vectorize-code-with-different-execution-paths-2.html, https://community.khronos.org/t/if-statements-in-shaders-confused-by-results/73518/7, https://www.reddit.com/r/GraphicsProgramming/comments/vrafmt/question_about_gpus_and_simd/)
- https://gamedev.stackexchange.com/questions/62648/what-does-ddx-hlsl-actually-do
- lerp(x, y, step(a, b))
- simd 는 어셈블리로 이해해야겠네.
- 기본적으론 vector이지만 텍스쳐등로 vector를 읽지 않는 이상 다 같은 값이 적용 되지 않을까?
- gpu simd https://developer.nvidia.com/blog/using-cuda-warp-level-primitives/
- elixir 에 for break는 없고 Enum.reduce가 더 많이 쓰이는 이유? reduce_while은 비효율적인 이유?
26. character 조립 확실히
27. vec3(0.2126f, 0.7152f, 0.0722f) Luminance Coefficients
28. resourcebundle이 되어 다른 asset의 폴더를 가져감
- resourcebundle은 몬스터 A, 몬스터 B 같은 조립 정보 그외 asset/character는 실제 리소스
- 모든 리소스는 폴더에 따른 번들 이름을 가짐 
29. c# marshal (https://hwanine.github.io/network/Marshalling/)
30. GGX PBS Schick Fresnel (https://lifeisforu.tistory.com/500; https://blog.naver.com/canny708/221551990444)
31. deep learning (https://www.youtube.com/watch?v=ENMtsWy52WA)
32. ndotl, ndotv, ndoth (https://madumpa.blogspot.com/2019/01/ndotl.html)
33. tagent space
34. assetstudio
35. Ramp Wrap Light (Toony Colors Pro 2, PhotoFilters, https://github.com/GameDevBox/Custom-Lighting-Toon-Ramp)
36. Toony Colors Pro 2(https://chulin28ho.tistory.com/543)
coding3study@gmail.com
37. 곱셈(필터링) 덧셈 밝기 추가
38. vulkan (https://ogldev.org/www/tutorial50/tutorial50.html)
39. surf shader principle (https://docs.unity3d.com/Manual/SL-SurfaceShaderLightingExamples.html)
40. custom lighting in shader graph (https://darkcatgame.tistory.com/89)
- https://unity.com/kr/blog/engine-platform/custom-lighting-in-shader-graph-expanding-your-graphs-in-2019
- https://darkcatgame.tistory.com/89
- https://chulin28ho.tistory.com/559
41. water (https://roystan.net/articles/toon-water/; https://darkcatgame.tistory.com/30)
- reflection (probe reflection or render target?)
- refraction
- GL.invertCulling = true
42. quaternion (https://www.youtube.com/watch?v=vpPWoCEs-xs&list=PLrrTotxaO6khV32NMle-VYOou5gK52Q_1&index=3)
43. 튜링 머신 (계산 능력)
44. 현재 바인딩 된 프레임 버퍼의 칼라 attachement 텍스쳐는 쉐이더에서 셈플링 불가
- 유니티에선 blit 이고 opengl 로 이전 프레임 버퍼의 칼라 텍스쳐를 액티브 텍스쳐로 지정해 쉐이더에서 읽는건 가능
- UI blur 처리시 grap pass를 쓰고 있는데 pipe line stage 병렬처리가 깨짐
- 더욱이 모든 화면을 전부 copy하는거라 사용하지 않는 부분도 복사하여 비효율적
- two multi target으로 밝은 부분만 따로 출력
45. opengl GLFW library c++ solution type
46. learn c++ (https://www.learncpp.com/)
47. 손 글씨&다이어그램 (https://excalidraw.coem/; XP-PEN Deco MINI 7)
48. post process (실루엣, 엑스레이)
49. built-in to srp (https://shakddoo.tistory.com/entry/Unity-Built-in-to-URP-%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0)
50. multi-directional light, proxy light (indirect)
51. anti-aliasing (https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing)
- SSAA 보이는 것보다 크게 그리고 다운 셈플링하면서 지그재그 삭제. 비용큼. 지금은 사용 안함
- MSAA 하드웨어서 실행. 픽셀당 한번의 픽셀쉐이더 실행되고 그 출력 된 한가지 색상에 대해 그 색상의 좌표 범위에 대한 
- x2, x4, x8에 대한 subsample을 하여 통과한 subsample을 혼함
52. framebuffer
- os에서 기본 제공하는 graphic api가 컨트롤 못하는 framebuffer를 사용자가 생성하여 사용 가능
- color attachement에 linear 지정, 여러개의 attachement 사용, anti-aliasing 사용 기본에선 할 수 없는 옵션 이용 가능
- 단 anti-aliasing(msaa) 사용시엔 blit으로 anti-aliasing 데이터를 decoding하여 텍스쳐를 새로 만들고 
- 그걸 다시 인풋 텍스쳐로 읽어 glBindFramebuffer(GL_FRAMEBUFFER, 0)를 하여 os 기본 프레임 버퍼에 quad 버텍스로 (화면크기) 다시 그림
53. shader_feature vs multi_compile (https://chulin28ho.tistory.com/591)
- shader_feature는 Material Keywords로 사용. multi_compile은 전역 키워드로 사용. 
- 전자는 모든 머터리얼에서 사용하는 keywords를 모아 그중 사용안하는 건 삭제
- 후자는 전역적으로 사용하는 keyword에 사용
- #pragma shader_feature _USE_DISSOLVE_NOISE
- #if defined(_USE_DISSOLVE_NOISE)
-          // Dissolve 노이즈 텍스처 사용
-            half noise = tex2D(_DissolveNoiseTex, IN.uv_MainTex).r;
-            c.rgb *= noise;
- #endif
- dissolveMaterial.EnableKeyword(USE_DISSOLVE_KEYWORD);
54. srp batcher (https://discussions.unity.com/t/srp-batcher-and-gpu-instancing/777746)
- skinned mesh 는 원래 batch가 안됨. 하지만 상하체 분리 된 skinned mesh renderer이지만 본을 공유하는 경우는?
- 이것도 안되지만 파츠를 런타임에 합치면 가능은 함
55. shader category = character(hair/face/body), none character, terrain, fx
56. normal vs tangent space (https://www.youtube.com/watch?v=6_-NNKc4lrk&t=15s;http://jerome.jouvie.free.fr/opengl-tutorials/Lesson8.php)
- tangent space -> uniform & 많은 노멀 
57. heightmap normal 
- ?
58. true type font
59. xray shader (https://www.youtube.com/watch?v=WmnYhIwWYfU)
60. programming language (https://tech.devsisters.com/posts/programming-languages-1-type-theory)
- int? length = nickname?.Length;
61. client 최적화
- zstring
- effect data/spawn/pooling
- _update 
- prebuild(preassemble)
- concurrent async resource load (based on resource dependency map)
62. server 최적화
- batch sql/network
- global memory cache
- distribute system
63. LUT Mapping (https://docs.unity3d.com/Packages/com.unity.sensorsdk@2.0/manual/UserGuide/UseLUTMappingForVisualization.html)


기저 벡터를 tangent, bitangent, normal로 칭하고 텍스쳐 좌표 UV 에

tangent, bitangent가 매칭되고 두 벡터의 대한 직교 벡터가 normal 인 공간을

말한다.

텍스쳐 공간이란 3D 모델의 표면에 대한 로컬 좌표계로, 기저 벡터로 tangent, bitangent, normal을 

사용합니다. 

이 공간에서 tangent와 bitangent는 텍스쳐의 U와 V 축에 각각 대응되며, normal은 이 두 벡터에 

수직인 벡터입니다.

기저 벡터들의 관계를 더 정확하게 설명합니다.
UV 좌표와 tangent, bitangent의 관계를 더 명확히 합니다.


trigger, layer, volume, Profile <-> framebuffer 

quick cpu
https://coderbag.com/product/quickcpu

https://docs.unity3d.com/Manual/LinearRendering-LinearOrGammaWorkflow.html
https://forum.unity.com/threads/question-about-gamma-and-linear-work-flow-in-unity.1147007/



https://panoskarabelas.com/posts/screen_space_shadows/
https://forum.unity.com/threads/what-are-screen-space-shadows.1363755/

https://www.geeksforgeeks.org/problems/median-in-a-row-wise-sorted-matrix1527/0

https://bytewrangler.blogspot.com/2011/10/signed-distance-fields.html
https://linkmemo.tistory.com/category/C%2B%2B%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D
https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii


https://stackoverflow.com/questions/20895648/difference-in-make-shared-and-normal-shared-ptr-in-c




	fixed4 FragBloom(VaryingsDefault i) : SV_Target
	{
		half4 color = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.texcoord);
		return color;
		
		//color.rgb = tonemap_uc2(color.rgb);

		//  // reinhard tone mapping
		//  half3 mapped = color / (color + half3(1.0, 1.0, 1.0));
		//  // gamma correction 
		//  mapped = pow(mapped, half(1.0) / 2.2);
		//  color = half4(mapped, color.a);	
		// return color;

		half3 bloom = SAMPLE_TEXTURE2D(_Bloom_Result, sampler_Bloom_Result, i.texcoord).rgb *
			ONE_MINUS_THRESHHOLD_TIMES_INTENSITY;
		color.rgb += bloom;

		#if UNITY_COLORSPACE_GAMMA
			color.rgb = clamp(color.rgb, 0, 4);
			color.rgb = GammaToLinearSpace(color.rgb);
		#endif

		color.rgb = tonemap_uc2(color.rgb);
		color.rgb = (color.rgb - 0.5h) * CONTRAST + 0.5h;

		color.rgb *= _RemapColor.rgb;

		fixed lum = Luminance(color.rgb);
		color.rgb = lerp(fixed3(lum, lum, lum), color.rgb, SATURATION);

		//#if UNITY_COLORSPACE_GAMMA
		//color.rgb = LinearToGammaSpace(color.rgb);;
		//#endif

		return color;
	}



  네, 물론입니다. 각 속성에 대한 코드 예시를 들어 설명해 드리겠습니다.

1. Metallic (금속성):
```glsl
float metallic = _Metallic * texMask.g;
```
이 코드는 금속성을 계산합니다. _Metallic은 전체적인 금속성 값이고, texMask.g (녹색 채널)로 세부 조정합니다.

예시 사용:
```glsl
// 반사 계산
float3 reflection = CalculateReflection(viewDirection, normal);
float3 finalColor = lerp(albedo, reflection, metallic);
```

2. Smoothness (매끄러움):
```glsl
float smoothness = _Glossiness;
```
매끄러움은 _Glossiness 값으로 직접 설정됩니다.

예시 사용:
```glsl
// 스페큘러 하이라이트 계산
float specPower = exp2(smoothness * 11.0) + 2.0;
float3 specular = CalculateSpecular(lightDir, viewDir, normal, specPower);
```

3. Glossiness (광택):
```glsl
float glossiness = texMask.r;
```
광택은 텍스처 마스크의 빨간 채널에서 가져옵니다.

예시 사용:
```glsl
// 프레넬 효과 계산
float fresnel = pow(1.0 - saturate(dot(normal, viewDir)), 5.0) * glossiness;
finalColor += fresnel * specularColor;
```

4. Emission (방출):
```glsl
float3 emission = _Emissive.rgb * texMask.b;
```
방출 색상은 _Emissive 색상과 텍스처 마스크의 파란 채널을 곱하여 계산합니다.

예시 사용:
```glsl
// 최종 색상에 방출광 추가
finalColor += emission;
```

이러한 속성들을 조합하여 사용하는 예시:

```glsl
void surf (Input IN, inout SurfaceOutputStandard o)
{
    // 기본 텍스처와 속성들 샘플링
    fixed4 c = tex2D (_MainTex, IN.uv_MainTex);
    fixed4 texMask = tex2D (_MaskTex, IN.uv_MaskTex);
    
    o.Albedo = c.rgb;
    o.Metallic = _Metallic * texMask.g;
    o.Smoothness = _Glossiness;
    o.Emission = _Emissive.rgb * texMask.b;
    
    // 광택을 사용한 추가적인 스페큘러 계산
    float glossiness = texMask.r;
    float3 specular = CalculateSpecular(IN.worldNormal, IN.viewDir, _LightColor0.rgb, glossiness);
    
    // 최종 색상 조합
    o.Albedo = lerp(o.Albedo, specular, o.Metallic);
    o.Albedo += o.Emission;
}
```

이 예시에서는 각 속성이 어떻게 서로 상호작용하여 최종 표면 외관에 영향을 미치는지 볼 수 있습니다. 실제 구현은 사용하는 렌더링 파이프라인과 쉐이더 모델에 따라 다를 수 있습니다.

https://claude.ai/chat/04e74493-da9f-4a17-8bc7-1b7c8c03fed8

Substance Painter