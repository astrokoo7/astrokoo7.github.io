---
layout: post
title: "Skinning"
categories: graphics
---

## Overview

버텍스 데이터 집합인 메쉬는 월드에 배치될 때 로컬 좌표계가 월드 좌표계로 선형 변환 되며 메시의 각 버텍스는 변환에 사용된 행렬과 곱하여 월드 공간상에 놓이게 된다. 

<!-- begin_excerpt -->

이는 버텍스에 영향을 미치는 행렬이 하나로 행렬 값의 변경은 모든 버텍스에 동일하게 적용되어 메쉬 자체의 모양은 변하지 않는다.

이에 반해 animation에서 사용하는 skinning 기술은 메쉬 하나에 한개 이상의 다중 행렬이 존재 할 수 있다. 

<!-- end_excerpt -->

> <font size="2"> 
> 이 행렬을 본(bone)이나 관절(joint)로 부르며 3D 모델링 툴에선 행렬을 서로 연결하여 본으로 그리고 연결점인 행렬은 관절로 표현한다.
> </font>

메쉬의 각 버텍스는 다중 행렬 중 어떤 행렬들이 얼마의 가중치(weight)로 영향을 미치는지에 대한 설정 정보가 필요하고 이 정보를 토대로 메쉬는 하나의 행렬이 아닌 다중 행렬에 영향받게 된다.

animation은 이 다중 행렬을 시간에 따라 각각 다르게 설정하여 메쉬에 한개의 모양이 아닌 다양한 모양을 만들 수 있게 해준다.


## Bindpose

메쉬에 하나의 행렬만 존재한다면 기준축이 하나라서 그 축 기준으로 버텍스 좌표를 만들고 월드에 배치할 때 기준축인 로컬 좌표계를 월드 좌표계로의 변환 행렬을 만든 다음 메쉬의 버텍스와 곱하여 버텍스를 월드에 배치할 수 있었다.

하지만 메쉬가 메쉬에 종속적인 하나의 행렬이 아닌 여러 개의 행렬에 영향을 받는다면 메쉬의 버텍스를 월드로 배치하기 위해 다른 방법이 필요해졌다.

만약 메쉬에 하나의 본만 있다고 생각하고 메쉬와 본의 중심만 맞춘다면 문제 될 것이 없다. 본의 로컬 좌표계에서 보나 메쉬의 로컬 좌표계에서 보나 버텍스의 위치 값은 같기 때문에 본을 따라가는 메쉬를 월드에 배치할때 본의 월드 행렬로 선형 변환해도 문제가 없기 때문이다.

하지만 여러 개의 본이 있다면 각 본의 로컬 좌표계에서 바라본 메쉬의 버텍스 좌표 값과 메쉬의 로컬 좌표계에서 바라본 버텍스의 좌표 값이 제각각 달라지게 된다. 이는 메쉬의 버텍스를 영향 받는 본의 월드 행렬로 선형 변환하여 버텍스를 월드에 배치할 때 문제가 발생하게 된다.

<figure>
<div style="text-align:center;">
  <img src="{{ site.url }}{{ site.baseurl }}/assets/images/bone.png" width="80%">
  <figcaption></figcaption>
</div>
</figure>

노란색 본의 영향을 받는 초록색 버텍스를 노락색 본의 월드 변환 행렬로 그대로 곱하면 버텍스의 위치에 노락색 본의 위치 값까지 더해져 원래의 위치를 한참 벗어나게 된다. 

이를 해결하기위해 각 본의 root bone에 대한 역행렬 값을 계산하여 bindpose에 저장하고   있다가 버텍스에 본의 월드 행렬을 곱한 값에 역행렬 만큼 곱하여 버텍스 위치를 조정해준다. 위 녹색의 화살표가 bindpose를 곱하여 버텍스 위치를 재조정해 주는 부분이다.

본은 월드에서 animation에 의해 계속 움직이고 그에 따라 본의 월드 행렬도 계속 변경 된다. 메쉬의 버텍스는 움직이는 본 중 영향 받는 본의 가중치 만큼 변형되어 월드상에 배치 된다. 

```c# 

    void Update()
    {
        SkinnedMeshRenderer skin = GetComponent<SkinnedMeshRenderer>();
        var mesh = skin.sharedMesh;

        Matrix4x4[] boneMatrices = new Matrix4x4[skin.bones.Length];
        for (int i = 0; i < boneMatrices.Length; i++)
            boneMatrices[i] = skin.bones[i].localToWorldMatrix * mesh.bindposes[i];

        Vector3[] vertices;

        var vertexCount = mesh.vertexCount;
        vertices = new Vector3[vertexCount];

        for (int i = 0; i < mesh.vertexCount; i++)
        {
            BoneWeight weight = mesh.boneWeights[i];

            Matrix4x4 bm0 = boneMatrices[weight.boneIndex0];
            Matrix4x4 bm1 = boneMatrices[weight.boneIndex1];
            Matrix4x4 bm2 = boneMatrices[weight.boneIndex2];
            Matrix4x4 bm3 = boneMatrices[weight.boneIndex3];

            Matrix4x4 vertexMatrix = new Matrix4x4();

            for (int n = 0; n < 16; n++)
            {
                vertexMatrix[n] =
                    bm0[n] * weight.weight0 +
                    bm1[n] * weight.weight1 + 
                    bm2[n] * weight.weight2 +
                    bm3[n] * weight.weight3;
            }

            vertices[i] = vertexMatrix.MultiplyPoint3x4(mesh.vertices[i]);
        }
    }

```

Unity는 Skinned Mesh Renderer에 의해 내부적으로 버텍스 좌표를 계산하여 유저가 직접 본 연산을 할 필요는 없다. mesh의 bindposes와 본의 world transfer matrix 그리고 vertex의 bone weight 값을 읽어와 역으로 월드 좌표계로 변환 된 버텍스 좌표를 계산할 수 있다.

